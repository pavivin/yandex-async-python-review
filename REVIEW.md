# Ревью

Привет!
В следующий раз лучше писать в чат, когда понимаешь что не можешь сдвинуться с мёртвой точки.

Помечу главные моменты, которые помогут тебе сдвинуться, после того как сделаешь можешь заняться более мелкими правками.

## Основные моменты

- Используешь __@coroutine__ прямо в планировщике. Получается, асинхронно забираешь список задач. В данном случае, это не имеет смысла, так как это не улучшает производительность. Нужно запускать задачи асинхронно. Чтобы это работало, нужно использовать __@coroutine__ внутри __Job__.

Ссылка на код

Дальше, используешь multiprocessing. Решение должно основываться на корутинах, так что предлагаю сделать в три этапа:

1. Создать стандартный планировщик без корутин, многопроцессорности и много поточности. ([Пример](https://www.youtube.com/watch?v=lQjA6md235U)). Также использовать pythontutor.com для понимания того, как идёт процесс выполнения задач.
2. Переделать задачи в корутины и вызывать их в планировщике
3. Добавить запуск корутин в multiprocessing
([Пример 1](https://stackoverflow.com/questions/55088249/python-multiprocessing-with-async-functions),
[Пример 2](https://sorokin.engineer/posts/en/python_asyncio_multiprocessing.html))


### Использование multiprocessing

Чтобы сделать планировщик более универсальным, надо определить зависящие друг от друга методы.

Статья с примерами разных задач в multiprocessing.
https://zetcode.com/python/multiprocessing/

Когда используешь condition, то не вызываешь методы notify и notify_all.
Статья о том, как использовать condition
https://superfastpython.com/multiprocessing-condition-variable-in-python/

## Для запуска

- Нет папки "jokes" и файла "punchline.txt"
  - Можно приложить к решению или создавать если нет (в функции open это можно сделать)
- Нет файла или модуля "logger"
  - Добавить файл с конфигурацией логгера

## Мелкие правки

- Не отформатировано по PEP8.
  - Можно установить black - это форматтер, с которым не придётся постоянно править код руками (<https://semakin.dev/2020/05/black/>)
- Декоратор два раза определён в файлах job и scheduler. Это нарушает принцип DRY (<https://blog.vverh.digital/2022/dont-repeat-yourself-or-dry/>). Повторяющиеся части кода можно вынести в отдельный файл и импортировать из него.
- Где-то используется print, где-то логирование. Все выводы лучше именно логировать, они будут в едином формате, также будут в одном месте, если например захочешь писать в файл.
- В контейнерах (list, dict) указывай какие типы данных будет. Подсказки типов будут лучше и писать код можно писать без очевидных ошибок

Вместо

```python
    def schedule(self):
        processes = []
```

Надо

```python
    def schedule(self):
        processes: list[YourType] = []
```

- Класс Scheduler явно наследуется от object, с 3 версии Python это не нужно делать. Аналогично с super().__init__()
- В методах copy_file и delete_file используется параметр x=None. Он нужен для универсальности использования методов. Лучше явно назвать что это за метод, либо использовать args и kwargs.
- Смешаное использование модулей shutil и os для создания / удаления файлов. Лучше использовать один.

## Итого

1. Используйте корутины и генераторы при решении. Использование потоков и процессов не запрещено, но база решения должна строиться на использовании корутин. (+-)
2. Использовать встроенные библиотеки и модули языка. (+)
3. Используйте концепции ООП. (+)
4. Используйте аннотацию типов. (-)
5. Логируйте результаты действий. (+-)
6. Покройте написанный код тестами. (-)
7. Предусмотрите обработку исключительных ситуаций. (+)
8. Приведите стиль кода в соответствие pep8, flake8, mypy. (-)
